package hyman.springbootdemo.util;

/**
 * 自定义非检查类异常，只用于业务处理失败时，抛出异常。
 *
 * 只要我们检查到业务处理失败时，就可以直接 throw 一个自定义异常，异常机制会帮助我们中断代码执行。有2种选择:
 * 1，在controller 使用try-catch进行处理。
 * 2，直接把异常抛给上层框架统一处理。
 *
 * 第1种方式是不可取的，注意我们抛出的ServiceException，它仅仅逻辑处理异常，并且在控制器的方法前面没有声明throws ServiceException，
 * 这表示他是一个非受查异常。controller 也不需要关心会发生什么异常。
 *
 * 为什么不定义成受查异常呢？如果是一个受查异常，那么意味着 controller必须要处理你的异常。并且如果有一天你的业务逻辑变了，可能多一种
 * 检查项，就需要增加一个异常，反之需要删除一个异常，那么你的方法签名也需要改变，controller也随之要改变，这又变成了紧耦合，这和用状态
 * 码 123 表示处理结果没有什么不同。
 *
 * 我们可以为每一种检查项定义一个异常吗？可以，但是那样显得太多余了。因为业务逻辑处理失败的时候，根据我们需求只需要通知用户失败的原因
 * （通常应该是一段字符串），以及服务器受理失败的一个状态码（有时可能不需要状态码,这要看你的设计了），这样只需要一个包含原因属性的异常
 * 即可满足我们需求。
 *
 * 最后我们决定这个异常继承自RuntimeException，并且包含一个接受一个错误原因的构造器。这样controller层也不需要知道异常，只要全局捕获到
 * ServiceException做统一的处理即可。这无论是在struct1，2时代，还是springMVC中，甚至servlet年代，都是极为容易的!
 *
 *
 * 什么情况需要自定义异常：
 * 经常看到一些项目，在全局定义一个 AppException，然后所有地方都只抛出这个异常，并且把捕获的异常 case到这个AppException中。会有如下问题:
 * 浪费log日志存储空间,并且栈顶并不是最接近发生异常的代码位置。
 * 只有一种异常类,无法精准区分开异常类型。
 * 异常类后期难以修改以增加其携带的信息。
 *
 * 什么情况需要手动处理异常：你有能力处理异常，并且你知道如何处理。你有责任处理异常。
 *
 * 如何对异常进行分类：
 * 1，如果可以用一句话概括的话，那么就可以直接定义一个简单的异常，用于中断处理，并且与用户保持友好交互即可。
 * 2，如果不可能一句话描述清楚，并且包含附加信息，比如需要在日志或者数据库记录消息ID，此时可能专门针对这种重要/复杂业务创建独立异常。
 *
 * 上述两种情况，因为web系统是用户发起请求之后需要等待程序给予响应结果的。如果是后台作业或者复杂业务需要追溯性，这种通常用流程判断语句控制，
 * 要用异常处理。而且这些流程判断一定是在一个原子性处理中，并且检查到（不是遇到）的问题（不是异常）需要记录到用户可友好查看的日，则这种情况
 * 属于处理反馈，并不叫异常。
 *
 * 综上，异常通常分为如下几类（各类异常必须要有单独的日志记录，或者分级，分类可管理。有的时候仅仅想给三方运维看到逻辑异常）：
 * 1，逻辑异常，这类异常用于描述业务无法按照预期的情况处理下去,属于用户制造的意外。自定义。
 * 2，代码错误，这类异常用于描述开发的代码错误，例如NPE，ILLARG 等非检查类异常，都属于程序员制造的BUG。
 * 3，专有异常，多用于特定业务场景，用于描述指定作业出现意外情况无法预先处理。自定义。
 *
 *
 * 但需要注意，异常设计的初衷是解决程序运行中的各种意外情况，并不是业务逻辑检查，并且异常的处理效率比条件判断方式要低很多。
 * 1，系统有千万并发，不可能还去考虑这些中规中矩的按部就班的声明异常抛出的方式处理业务，别忘了MVC本来就浪费很多资源，代码量增加很多。
 * 2，业务系统也存在很多巨量任务处理的情况。但是那些任务都是原子性的，现在MVC中的controller和service可不是原子性的，不然为什么要区分这么多层呢。
 * 3，如果那么在乎效率，考虑下重写Throwable的fillStackTrace方法。要知道异常的开销大到底大在什么地方，fillStackTrace是一个native方法，会填充异常类内部的运行轨迹。
 *
 * 例如在处理消息验证，消息解析，消息入库时，如果处理有问题就总是抛出验证异常，解析异常，入库异常等等。这种方式需要严重的禁止！我们提倡在业
 * 务处理的时候，如果发现无法处理直接抛出异常即可。而并不是在逻辑处理的时候，用异常来判断逻辑进行的状况（而是将错误信息封装并返回）。
 */
public class ServerException extends RuntimeException{

    // 接收reason参数用来描述业务失败原因
    public ServerException(String reason) {  super(reason); }
}

